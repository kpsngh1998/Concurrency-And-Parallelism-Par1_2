Course Title: Parallel and Concurrent Programming with Java 2

Description: With parallel computing, you can leverage multiple compute resources to tackle larger problems in a shorter amount of time. In this course, the second in the Parallel and Concurrent Programming with Java series, take a deeper dive into the key mechanisms for writing concurrent and parallel programs. Instructors Olivia and Barron Stone make these (often abstract) concepts down-to-earth, demonstrating key ideas using common kitchen activities. Learn all about synchronization, thread pools, asynchronous tasks, evaluating parallel performance, designing parallel programs, and more. Upon wrapping up this course, you'll have a solid understanding of how to parallelize a sequential program.


***********************************************
Chapter: 2. Barriers
***********************************************


-----------------------------------------------
Video: Race condition: Java demo
-----------------------------------------------
Note Time:         Note Text:                     

0:00:28            Race condition: Java demo
Selecting transcript lines in this section will navigate to timestamp in the video
- [Narrator] This example demonstrates a race condition in Java. It has a class named shopper, which will execute as a thread, that either adds or multiplies the value of the bags of chips, class variable, on line nine, which represents the number of chips we should buy for the party. Down in the program's main method, I use a for loop on line 41, to instantiate 10 shoppers. Five of those threads are named Barron, with a unique number afterwords, and the other five are named Olivia. As in our kitchen scenario, the five Olivia threads will each add three bags of chips to the shared variable, whereas the five Barron threads will each double the amount of chips. That's accomplished in the shopper classes run method, by using an if, else statement, beginning on line 17, that checks the name of the thread. Notice that in either case, the shopper is locking and unlocking a reinterent lock named pencil, which serves as the shared new text to protect access to the shared bags of chips variable. Since only one thread can read or write that variable at a time, this program is protected against having a data race, but it's still vulnerable to a race condition. To show that, I'll run the program. And after all 10 threads finish, it prints a message that we need 242 bags of chips. Now if I run it again, this time we need 344 bags of chips. The relative order in which Barron and Olivia's threads were scheduled to add and multiply the bags of chips was different, which gave me a different result. And if I run it again, I get yet another answer. Again, the problem here is not a data race, because I've guaranteed mutual exclusion, by having the shoppers lock the pencil before modifying the bags of chips. However, there is a race condition here because the order in which these threads get scheduled to execute, changes the final result. 


-----------------------------------------------
Video: Barrier
-----------------------------------------------
Note Time:         Note Text:                     

0:00:29            Barrier
Selecting transcript lines in this section will navigate to timestamp in the video
- To prevent our race condition from occurring, we need a way to synchronize our actions so we execute our respective multiplication and addition operations in the correct order. And we can do that with something called a barrier. A barrier is a stopping point for a group of threads that prevents them from proceeding until all or enough threads have reached the barrier. I like to think of threads waiting on a barrier like players on a sports team coming together for a huddle. Before they join the huddle, the players might be doing other things, putting on their equipment or getting a drink of water. As they finish those individual activities, they join their teammates at the huddle. Players in the huddle wait there until all of their fellow teammates arrive. Then they all yell, "Break," and then they scatter about to continue playing their game. - We can use a similar strategy here to solve our race condition, huddling together to synchronize when we each execute our operations, to add and multiply items on the shopping list. I should complete my operation of adding three bags of chips to the list before we huddle together. Then, afterwards, Barron can double the amount. - Sounds good. - I'm scheduled to execute first this time, so I'll acquire the pencil. I'll add my three bags of chips to the list and release my lock on the pencil and then meet you at the huddle. Don't leave me hangin'. - I don't have anything to do before the huddle, so. - [Barron & Olivia] Break. - Now we're past the barrier. So I'll double the number of chips. That gives us eight, which is the right amount. By using a barrier, the order in which our threads actually get scheduled to execute doesn't matter because the barrier synchronizes us. Olivia always adds three bags before the barrier and I multiply by two after it. If we were to run that program again and I happened to get scheduled first, well, I don't have anything to do before the barrier, so I'll wait for Olivia. - When I eventually get scheduled to execute, I'll complete my operations then join the barrier. - [Barron & Olivia] Break. - Now I'm free to continue doing whatever else I need to do. I'm going to see if we have any salsa. - And I can double the chips on our shopping list. Although the order in which our threads got scheduled was different, the end result is the same. We need eight bags of chips for the party. 


-----------------------------------------------
Video: Barrier: Java demo
-----------------------------------------------
Note Time:         Note Text:                     

0:03:58            Barrier: Java demo
Selecting transcript lines in this section will navigate to timestamp in the video
- [Instructor] To show you how to implement a barrier in Java I'll build on the previous example that demonstrated a race condition by creating 10 shopper threads that either added or multiplied the number of chips to buy, depending on if the thread was named Barron or Olivia. Without a barrier in place, if I run this program, it has a race condition that'll produce different results every time I run it. So, I'll use Java's cyclic barrier to make sure all five of the Olivia threads, execute their add operation before the five Barron threads multiply the bags of chips. The cyclic barrier is included in the Java concurrent package, so I'll import that at the top of the program. Then, I'll instantiate a new CyclicBarrier object called fistBump as a static variable in the Shopper class. The constructor takes an argument for the number of threads to wait on before the barrier releases. Since this program instantiates 10 shopper threads total, five named Barron and five named Olivia, and I want all of them to arrive at the barrier together before the program continues, I'll give it an input of 10. Now that I've created the barrier, it's time to figure out where to use it. In this program I'm starting all of the shopper threads together, and I can't control when each one will get scheduled to execute. But all I really care about here is making sure that all of the Olivia threads execute their addition operation before the Barron threads execute the multiplication. So I'll use my barrier to separate those operations. The Olivia threads will execute their addition operations before they wait at the barrier, whereas the Barron threads will go straight to waiting at the barrier. Once all 10 threads have arrived at the barrier and are waiting on it, then the barrier will release and the Barron threads will all execute their multiplication operations. Going back to code and looking at the run method, to implement that for the Olivia shoppers, I'll add the code to wait on the barrier after adding three bags of chips on line 22 and then releasing the pencil lock. I'll start a try statement and put the call to fistBump.await inside of it. Then, on the next line I'll need to include a catch clause. And there are two types of exceptions that can be thrown by the cyclic barrier, the usual InerruptedException and another one called BrokenBarrierException. I'll use the pipe operator to catch either of those if they occur and then print a stack trace. Now, I'll copy those lines of code for waiting on the barrier, and down in the Barron case I'll paste them before the Barron thread takes the pencil to execute its multiplication operation. I'll build and run this program. And now all of the Olivia shoppers execute their addition operation first, and then all of the Barron shoppers do their multiplication afterwards. That gives me a final total of 512 bags of chips. And if I run this program again I'll always get that same answer. This type of barrier is called cyclic because it can be reused after the waiting threads are released. Java's cyclic barrier has a few other useful methods. GetParties gives you the total number of threads needed to trip the barrier. GetNumberWaiting returns the number of threads that are currently waiting on the barrier. The reset method allows you to reset the barrier to its initial state so you can reuse the barrier object. And finally, the isBroken method can be used to check if one of the threads waiting on the barrier has broken out due to an interruption or timeout since the barrier was constructed or last reset. 


***********************************************
Chapter: 3. Asynchronous Tasks
***********************************************


-----------------------------------------------
Video: Future
-----------------------------------------------
Note Time:         Note Text:                     

0:01:02            Future
Selecting transcript lines in this section will navigate to timestamp in the video
- Launching asynchronous tasks is a great way to accomplish multiple things at once. - Olivia, can you go check how many vegetables are in the pantry? - Sure, I can do that. - While Olivia is busy asynchronously counting veggies, my thread is free to continue doing other work. But now she's gone and I need a way to get that result back from her when she's done. This is where a mechanism called a future can be used. A future acts as a placeholder for a result for a result that's initially unknown, but will be available at some point in the future. It provides a mechanism to access the result of an asynchronous operation. I like to think of a future like an IOU note for the result. Hey Oliva! - Hey-o. - Hey, I need you to check how many vegetables are in the pantry and give me back an answer. - Sure, I promise to do that and here's an IOU note that I'll get you that answer. - Thank you. Now I've got a handle to see that future result and I'll hold onto it as I continue doing other work in the kitchen. Eventually, I may reach a point in my work that I need the result from Olivia, perhaps to make a decision or complete some type of computation. The future is read-only and I see that the result isn't ready yet, so all I can do is wait until Olivia finishes. When she finally does, she'll write the result value to that future, which is called resolving or fulfilling it. She's fulfilling her promise to get me an answer and I see we have zero veggies left in the pantry. - We chopped them all up making salads. - Well, at least now I have an answer and know I need to make a trip to the store. 

